class Bishop():
    # Bishop - слон
    def __init__(self, color):
        # "__init__" - это метод, который используется для инициализации нового созданного объекта
        self.color = color
        # в color - цвет фигуры
        self.name = "B"
        # в name - имя фигуры (p, Q, K и т.д.)

    def is_valid_move(self, board, start, to):
        # is_valid_move - возможен ли ход
        # board - класс доски
        # start - начальная координата
        # to - конечная коордианата
        if abs(start[0] - to[0]) == abs(start[1] - to[1]) and 0 <= start[1] <= 7 and 0 <= to[1] <= 7 and abs(
                start[0] - to[0]) != 0:
            a = start[0]
            # а - коордианата фигуры по вертикальной оси в ее начальном положении
            b = start[1]
            # b - коордианата фигуры по горизонтальной оси в ее начальном положении
            while a != to[0]:
                # Проверка, нет ли чего-то между начальной точки слона и конечной
                a -= (abs(start[0] - to[0]) // (start[0] - to[0]))
                b -= (abs(start[1] - to[1]) // (start[1] - to[1]))
                if board.board[a][b] != '.' and a != to[0]:
                    return False
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                # Проверка, нет ли на конечной координате слона фигуры того же цвета
                return False
            return True
        return False  # Если конечная точка слона не на одной диагонале с ним


class Pawn():
    # Pawn - пешка
    def __init__(self, color):
        self.color = color
        self.name = "P"
        self.first_move = True
        self.move_count = 0 # считает количество ходов каждой фигуры
        self.two_move = False # проверка на то, был ли у пешки двойной ход
        self.take_on_path = False # было ли взятие на проходе
        # Проверка, не первый ли это ход

    def is_valid_move(self, board, start, to):
        if self.color == 0:
            # Для белой пешки
            if self.first_move and start[1] == to[1] and to[0] - start[0] == 2 and board.board[start[0] + 1][
                start[1]] == '.' and board.board[start[0] + 2][start[1]] == '.' and 0 <= start[1] <= 7 and 0 <= to[
                1] <= 7:
                # Это первый ход и пешка ходит на 2 клетки
                self.first_move = False
                self.move_count += 1
                self.two_move = True
                return True
            elif start[1] == to[1] and to[0] - start[0] == 1 and board.board[to[0]][to[1]] == '.' and 0 <= start[
                1] <= 7 and 0 <= to[1] <= 7:
                # Пешка ходит на 1 клетку
                self.first_move = False
                self.move_count += 1
                self.two_move = False
                return True
            elif abs(start[1] - to[1]) == 1 and to[0] - start[0] == 1 and board.board[to[0]][to[1]] != '.' and \
                    board.board[to[0]][to[1]].color != self.color and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
                # Если хочет съесть фигуру
                self.first_move = False
                self.move_count += 1
                self.two_move = False
                return True
            elif abs(start[1] - to[1]) == 1 and start[0] - to[0] == 1 and board.board[start[0]][to[1]] != '.' and \
                    board.board[start[0]][to[1]].name == 'P' and board.board[start[0]][to[1]].move_count == 1 and \
                    board.board[start[0]][to[1]].two_move and 0 <= start[1] <= 7 and 0 <= to[1] <= 7 and \
                    board.board[start[0]][to[1]].color != self.color:
                # Если было совершено взятие на проходе
                self.move_count += 1
                self.first_move = False
                self.take_on_path = True
                self.two_move = False
                return True

        else:
            # Для черной пешки (то же самое, но координаты наоборот)
            if self.first_move and start[1] == to[1] and start[0] - to[0] == 2 and board.board[start[0] - 1][
                start[1]] == '.' and board.board[start[0] - 2][start[1]] == '.' and 0 <= start[1] <= 7 and 0 <= to[
                1] <= 7:
                self.first_move = False
                self.move_count += 1
                self.two_move = True
                return True
            elif start[1] == to[1] and start[0] - to[0] == 1 and board.board[to[0]][to[1]] == '.' and 0 <= start[
                1] <= 7 and 0 <= to[1] <= 7:
                self.first_move = False
                self.move_count += 1
                self.two_move = False
                return True
            elif abs(start[1] - to[1]) == 1 and start[0] - to[0] == 1 and board.board[to[0]][to[1]] != '.' and \
                    board.board[to[0]][to[1]].color != self.color and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
                self.first_move = False
                self.move_count += 1
                self.two_move = False
                return True
            elif abs(start[1] - to[1]) == 1 and start[0] - to[0] == 1 and board.board[start[0]][to[1]] != '.' and \
                    board.board[start[0]][to[1]].name == 'P' and board.board[start[0]][to[1]].move_count == 1 and \
                    board.board[start[0]][to[1]].two_move and 0 <= start[1] <= 7 and 0 <= to[1] <= 7 and \
                    board.board[start[0]][to[1]].color != self.color:
                self.first_move = False
                self.move_count += 1
                self.take_on_path = True
                self.two_move = False
                return True


class Wizard():
    # Wizard - волшебник
    def __init__(self, color):
        self.color = color
        self.name = "W"

    def is_valid_move(self, board, start, to):
        # Так же, как у короля, проверяем возможность ходов вокруг себя
        if abs(start[0] - to[0]) <= 1 and abs(start[1] - to[1]) <= 1 and not (
                start[0] == to[0] and start[1] == to[1]) and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                return False
            return True
        # Тут реализуется проверка на возможность "телепортации"
        # Телепортация: перемещение с клетки (x, y) на (y, x)
        if start[0] == to[1] and start[1] == to[0] and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                # Проверка на то, не своя ли фигура на конечной клетке
                return False
            return True
        return False


class Samurai():
    # Samurai - самурай
    def __init__(self, color):
        self.color = color
        self.name = 'S'

    def is_valid_move(self, board, start, to):
        if abs(start[0] - to[0]) == 2 or abs(start[1] - to[1]) == 2 and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                # Проверка на то, не стоит ли на конечной координате фигура того же цвета
                return False
            return True
        return False  # Если так нельзя сходить


class Dragon():
    # Dragon - дракошка
    def __init__(self, color):
        self.color = color
        self.name = 'D'

    def is_valid_move(self, board, start, to):
        # 1 варианта хода:
        if abs(start[0] - to[0]) + abs(start[1] - to[1]) == 2 and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                # Проверка на то, не стоит ли на конечной координате фигура того же цвета
                return False
            return True
        return False  # Если так нельзя сходить


class Knight():
    # Knight - лошадка
    def __init__(self, color):
        self.color = color
        self.name = 'N'

    def is_valid_move(self, board, start, to):
        # 3 варианта хода:
        if abs(start[0] - to[0]) == 2 and abs(start[1] - to[1]) == 1 and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            # Если "г" - вертикальная
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                # Проверка на то, не стоит ли на конечной координате фигура того же цвета
                return False
            return True
        if abs(start[0] - to[0]) == 1 and abs(start[1] - to[1]) == 2 and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            # Если "г" - горизонтальная
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                # Проверка на то, не стоит ли на конечной координате фигура того же цвета
                return False
            return True
        return False  # Если это вообще не "г"


class King():
    # King - король
    def __init__(self, color):
        self.color = color
        self.name = "K"
        self.first_move = True
        # Первый ли ход для рокировки

    def is_valid_move(self, board, start, to):
        if abs(start[0] - to[0]) <= 1 and abs(start[1] - to[1]) <= 1 and not (
                start[0] == to[0] and start[1] == to[1]) and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                return False
            self.first_move = False
            return True
        return False

    def castling(self):
        # castling - рокировка
        self.first_move = False


class Queen():
    # Queen - королева. Ее ходы - это совмещение кода ладьи и слона
    def __init__(self, color):
        self.color = color
        self.name = "Q"

    def is_valid_move(self, board, start, to):
        # 4 варианта хода
        if abs(start[0] - to[0]) == abs(start[1] - to[1]) and 0 <= start[1] <= 7 and 0 <= to[1] <= 7 and abs(
                start[0] - to[0]) != 0:
            # Движение по диагонали. Тут код слона
            a = start[0]
            b = start[1]
            while a != to[0]:
                a -= (abs(start[0] - to[0]) // (start[0] - to[0]))
                b -= (abs(start[1] - to[1]) // (start[1] - to[1]))
                if board.board[a][b] != '.' and a != to[0]:
                    return False
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                return False
            return True
        if start[0] == to[0] and start[1] != to[1] and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            # Движение по горизонтали. Тут код ладьи
            a = start[1]
            while a != to[1]:
                a -= abs(start[1] - to[1]) // (start[1] - to[1])
                if board.board[start[0]][a] != '.' and a != to[1]:
                    return False
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                return False
            return True
        if start[0] != to[0] and start[1] == to[1] and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            # Движение по вертикали. Тут код ладьи
            a = start[0]
            while a != to[0]:
                a -= abs(start[0] - to[0]) // (start[0] - to[0])
                if board.board[a][start[1]] != '.' and a != to[0]:
                    return False
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                return False
            return True
        return False  # Если ход невозможен


class Checker():
    # Checker - шашка
    def __init__(self, color):
        self.color = color
        self.name = "C"

    def is_valid_move(self, board, start, to):
        if self.color == 0:
            # Если это белая шашка
            if start[0] - to[0] == -1 and abs(start[1] - to[1]) == 1 and board.board[to[0]][to[1]] == '.' and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
                return [1, 0] # Первый указывает возможен ли ход, второй - съел ли фигуру
            if start[0] - to[0] == -2 and abs(start[1] - to[1]) == 2 and board.board[start[0] + 1][start[1] - (start[1] - to[1])//2] != '.' and board.board[start[0] + 1][start[1] - (start[1] - to[1])//2].color == 1  and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
                # board.board[start[0] + 1][start[1] - (start[1] - to[1])//2] - определает фигуру, которую мы можем съесть
                return [1, 1]
            return [0, 0]
        if self.color == 1:
            # Если это черная шашка
            if start[0] - to[0] == 1 and abs(start[1] - to[1]) == 1 and board.board[to[0]][to[1]] == '.' and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
                return [1, 0]
            if start[0] - to[0] == 2 and abs(start[1] - to[1]) == 2 and board.board[start[0] - 1][start[1] - (start[1] - to[1])//2] != '.' and board.board[start[0] - 1][start[1] - (start[1] - to[1])//2].color == 0 and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
                return [1, 1]
            return [0, 0]


class Checker_Queen():
    # Checker - шашка
    def __init__(self, color):
        self.color = color
        self.name = "Q"

    def is_valid_move(self, board, start, to):
        if abs(start[0] - to[0]) == abs(start[1] - to[1]) and 0 <= start[1] <= 7 and 0 <= to[1] <= 7 and abs(
                start[0] - to[0]) != 0:
            a = start[0]
            # а - коордианата фигуры по вертикальной оси в ее начальном положении
            b = start[1]
            # b - коордианата фигуры по горизонтальной оси в ее начальном положении
            c = 0
            # с - количество фигур между начальной и конечной координатой
            while a != to[0]:
                a -= (abs(start[0] - to[0]) // (start[0] - to[0]))
                b -= (abs(start[1] - to[1]) // (start[1] - to[1]))
                if board.board[a][b] != '.' and board.board[a][b].color != self.color:
                    c += 1
                elif board.board[a][b] != '.' and board.board[a][b].color == self.color:
                    # На пути королевы фигура ее же цвета
                    return [0, 0]
            if board.board[to[0]][to[1]] != '.':
                # Если на конечной координате есть фигура, туда нельзя сходить
                return [0, 0]
            if c == 0:
                # Никого не съели, так как некого
                return [1, 0]
            elif c == 1:
                # Кого-то съели
                return [1, 1]

        return [0, 0]


class Rook():
    # Rook - башенка
    def __init__(self, color):
        self.color = color
        self.name = "R"
        self.first_move = True

    def is_valid_move(self, board, start, to):
        # 3 варианта хода:
        if start[0] == to[0] and start[1] != to[1] and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            # Если движемся по горизонтали
            a = start[1]
            while a != to[1]:
                a -= abs(start[1] - to[1]) // (start[1] - to[1])
                if board.board[start[0]][a] != '.' and a != to[1]:
                    return False
                    # Ход невозможен, если ладья перепрыгивает другие фигуры
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                return False
                # Ход невозможен, если фигура хочет сходить на клетку, в которой фигура того же цвета
            self.first_move = False
            return True
        if start[0] != to[0] and start[1] == to[1] and 0 <= start[1] <= 7 and 0 <= to[1] <= 7:
            # # Если движемся по вертикали. Работает аналогично движению по горизонтали
            a = start[0]
            while a != to[0]:
                a -= abs(start[0] - to[0]) // (start[0] - to[0])
                if board.board[a][start[1]] != '.' and a != to[0]:
                    return False
            if board.board[to[0]][to[1]] != '.' and board.board[to[0]][to[1]].color == self.color:
                return False
            self.first_move = False
            return True
        return False

    def castling(self):
        # Проверка на рокировку. Если рокировка произошла, то ход уже не первый
        self.first_move = False


class Board:
    def __init__(self, game = 0):
        self.board = [['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.']]
        # Вводим класс доски. Создаем доску как вложенный список
        self.color = 0
        if game == 0: # для шахмат
            # color 0 - белые фигуры, 1 - черные
            self.board[7][0] = Rook(1)
            # Rook - ладья
            self.board[7][1] = Knight(1)
            # Knight - конь
            self.board[7][2] = Bishop(1)
            # Bishop - слон
            self.board[7][3] = Queen(1)
            # Queen - королева
            self.board[7][4] = King(1)
            # King - король
            self.board[7][5] = Bishop(1)
            self.board[7][6] = Knight(1)
            self.board[7][7] = Rook(1)
            for i in range(8):
                self.board[6][i] = Pawn(1)
                # Pawn - пешка
            self.board[0][0] = Rook(0)
            self.board[0][1] = Knight(0)
            self.board[0][2] = Bishop(0)
            self.board[0][3] = Queen(0)
            self.board[0][4] = King(0)
            self.board[0][5] = Bishop(0)
            self.board[0][6] = Knight(0)
            self.board[0][7] = Rook(0)
            for i in range(8):
                self.board[1][i] = Pawn(0)
        else:
            # Для шашек:
            # Расставляем пешки по доске
            for i in range(0, 8, 2):
                self.board[0][i] = Checker(0)
                self.board[2][i] = Checker(0)
                self.board[6][i] = Checker(1)
            for i in range(1, 8, 2):
                self.board[1][i] = Checker(0)
                self.board[5][i] = Checker(1)
                self.board[7][i] = Checker(1)
        self.step = 1 # Счетчик ходов
        self.moves = [] # Сюда запоминаем все прошлые истории досок
        self.additional_move = False # Будет ли дополнительный ход (если фигура стала королевой или кого-то еще можно съесть)
        self.previous_piece = [] # Координаты фигуры, которой мы ходили в прошлой раз (для self.additional_move, чтобы ходить
        # в дополнительнои ходу только той фигурой, которой мы ходили в прошлом ходу)
        self.eaten = False # True \ False, определяющяя, можно ли кого-то съесть сейчас
    def move_record(self):
        # Для записи первой записи доски
        if self.step == 1:
            self.moves = [Board()]
    def current_player_color(self):
        return self.color
        # Возвращаем цвет текущего игрока
    def print_board(self):
        # Выводит доску
        print('    A B C D E F G H')
        print('')
        for i in range(8):
            row = ' ' + str(8 - i) + ' '
            for j in range(8):
                if self.board[7 - i][j] != '.':
                    # Если клетка не пустая, то мы задаем ей цвет
                    if self.board[7 - i][j].color:
                        # Если фигура черная
                        row += ' ' + self.board[7 - i][j].name.lower()
                        # фигура обозначается нижним регистром
                    else:
                        # Если фигура белая
                        row += ' ' + self.board[7 - i][j].name
                        # фигура остается в верхнем регистре
                else:
                    # Если нет фигур, то выводим пустую клетку (точку)
                    row += ' .'
            print(row + '  ' + str(8 - i))
        print('')
        print('    A B C D E F G H')

    def move_piece(self, board, start, to):
        # move_piece проверяет, возможен ли ход, и совершает его
        board.move_record() # Делаем начальную доску
        if self.board[start[0]][start[1]] != '.':
            # Есть ли в начальных координатах фигура
            if self.color == self.board[start[0]][start[1]].color:
                # Фигуру цвета текущего игрока двигают ли
                if self.board[start[0]][start[1]].is_valid_move(board, start, to):
                    flag_first_move = False
                    # Проверка на первый ход
                    if self.board[start[0]][start[1]].name in ['P', 'R', 'K'] and self.board[start[0]][
                        start[1]].first_move == True:
                        flag_first_move = True
                    # Проверка на возможность хода
                    a = None # Сюда будет записываться фигура, которую мы съели при взятии на проходе
                    if self.board[start[0]][start[1]].name == 'P' and self.board[start[0]][start[1]].take_on_path:
                        a = self.board[start[0]][to[1]]
                        self.board[start[0]][to[1]] = '.' # Заменяем съеденную фигуру точкой
                        self.board[start[0]][start[1]].take_on_path = False
                    self.board[to[0]][to[1]] = self.board[start[0]][start[1]]
                    # Создаем фигуру в новых координатах
                    self.board[start[0]][start[1]] = '.'
                    # Удаляем фигуру из старых координат
                    if self.color == 0 and board.is_under_check_w(board) or self.color == 1 and board.is_under_check_b(
                            board):
                        # Проверяем, находится ли король под шахом
                        self.board[start[0]][start[1]] = self.board[to[0]][to[1]]
                        self.board[to[0]][to[1]] = '.'
                        if self.board[start[0]][start[1]].name == 'P' and a:
                            self.board[start[0]][to[1]] = a # Если было взятие на проходе, то запоминаем ту пешку, которую съели, чтобы если что вернуть ее
                        # Если король под шахом, то мы переводим фигуру обратно, так как этот ход невозможен
                        if self.board[start[0]][start[1]].name in ['P', 'R', 'K'] and flag_first_move == True:
                            self.board[start[0]][start[1]].first_move = True
                        return False
                    if self.color == 0:
                        self.color = 1
                        # Меняем цвет текущего игрока
                    else:
                        self.color = 0
                    board_copy = Board()
                    board_copy.copy(board)
                    # Делаем копию доски
                    self.moves.append(board_copy)
                    # Добавляем эту копию в список с историей ходов
                    self.step += 1
                    return True
                    # Если король не под шахом, ход совершается
            return False
            # Если двигают фигуру не своего цвета
        else:
            return False
            # Если на начальной коордианте нет фигуры

    def rollback(self, board, num_moves = 1):
        # num_moves - то, на сколько мы хотим откатить ходов назад
        # rollback меняет доску на ту, до которой мы откатили ходы
        if num_moves > len(self.moves) - 1:
            print("Нельзя откатить на больше ходов чем есть")
            return
        self.step -= num_moves
        for i in range(num_moves):
            self.moves.pop(-1)
        board.copy(self.moves[-1])

    def change_piece(self, piece, row, col):
        # change_piece меняет пешку, дошедшую до противоположного конца доски на выбранную игроком фигуру.
        # В change_piece(self, piece, row, col) piece - фигура, на которую игрок хочет сменить пешку
        if row == 0:
            if piece == 'Q':
                self.board[row][col] = Queen(1)
            if piece == 'N':
                self.board[row][col] = Knight(1)
            if piece == 'R':
                self.board[row][col] = Rook(1)
            if piece == 'B':
                self.board[row][col] = Bishop(1)
            if piece == 'S':
                self.board[row][col] = Samurai(1)
            if piece == 'W':
                self.board[row][col] = Wizard(1)
            if piece == 'D':
                self.board[row][col] = Dragon(1)
        if row == 7:
            if piece == 'Q':
                self.board[row][col] = Queen(0)
            if piece == 'N':
                self.board[row][col] = Knight(0)
            if piece == 'R':
                self.board[row][col] = Rook(0)
            if piece == 'B':
                self.board[row][col] = Bishop(0)
            if piece == 'S':
                self.board[row][col] = Samurai(0)
            if piece == 'W':
                self.board[row][col] = Wizard(0)
            if piece == 'D':
                self.board[row][col] = Dragon(0)

    def castling_s(self, board):
        # castling_s - короткая рокировка (вправо)
        if self.color == 0:
            # Для белого короля
            if not (board.is_under_check_w(board)) and self.board[0][4] != '.' and self.board[0][4].name == 'K' and \
                    self.board[0][4].first_move and self.board[0][7] != '.' and self.board[0][7].name == 'R' and \
                    self.board[0][7].first_move and self.board[0][6] == '.' and self.board[0][5] == '.':
                # Проверка на месте ли король и ладья, первый ли это их ход, нет ли между ними фигур, не под шахом ли король
                self.board[0][4] = '.'
                self.board[0][5] = King(0)
                # Переставляем короля, чтобы проверить не будет ли на клетке e1 шаха
                if board.is_under_check_w(board):
                    # Если на е1 шах, переставляем все назад: ход невозможен
                    self.board[0][5] = '.'
                    self.board[0][4] = King(0)
                    self.board[0][6] = '.'
                    self.board[0][7] = Rook(0)
                    return False
                self.board[0][5] = Rook(0)
                self.board[0][6] = King(0)
                self.board[0][7] = '.'
                # Переставляем фигуры на место рокировки
                if board.is_under_check_w(board):
                    # Проверяем, не будет ли шаха при перестановке фигур на места рокировки
                    self.board[0][5] = '.'
                    self.board[0][4] = King(0)
                    self.board[0][6] = '.'
                    self.board[0][7] = Rook(0)
                    return False
                    # Если будет, переставляем фигуры обратно
                self.color = 1
                # Меняем цвет игрока
                self.board[0][4].castling()
                self.board[0][7].castling()
                # Делаем ход короля и ладьи уже не первыми
                board_copy = Board()
                board_copy.copy(board)
                self.moves.append(board_copy)
                self.step += 1
                return True
            else:
                return False
        if self.color == 1:
            # Для черного короля. Код аналогичен рокировке для белого
            if not (board.is_under_check_w(board)) and self.board[7][4] != '.' and self.board[7][4].name == 'K' and \
                    self.board[7][4].first_move and self.board[7][7] != '.' and self.board[7][7].name == 'R' and \
                    self.board[7][7].first_move and self.board[7][6] == '.' and self.board[7][5] == '.':
                self.board[7][4] = '.'
                self.board[7][5] = King(0)
                if board.is_under_check_w(board):
                    self.board[7][5] = '.'
                    self.board[7][4] = King(0)
                    self.board[7][6] = '.'
                    self.board[7][7] = Rook(0)
                    return False
                self.board[7][5] = Rook(0)
                self.board[7][6] = King(0)
                self.board[7][7] = '.'
                if board.is_under_check_w(board):
                    self.board[7][5] = '.'
                    self.board[7][4] = King(0)
                    self.board[7][6] = '.'
                    self.board[7][7] = Rook(0)
                    return False
                self.color = 1
                self.board[7][4].castling()
                self.board[7][7].castling()
                board_copy = Board()
                board_copy.copy(board)
                self.moves.append(board_copy)
                self.step += 1
                return True
            else:
                return False

    def castling_l(self, board):
        # Длинная рокировка (в левую сторону)
        # Аналогична короткой рокировке
        if self.color == 0:
            if not (board.is_under_check_w(board)) and self.board[0][4] != '.' and self.board[0][4].name == 'K' and \
                    self.board[0][4].first_move and self.board[0][0] != '.' and self.board[0][0].name == 'R' and \
                    self.board[0][0].first_move and self.board[0][1] == '.' and self.board[0][2] == '.' and \
                    self.board[0][7] == '.':
                self.board[0][4] = '.'
                self.board[0][3] = King(0)
                if board.is_under_check_w(board):
                    self.board[0][3] = '.'
                    self.board[0][4] = King(0)
                    return False
                self.board[0][3] = Rook(0)
                self.board[0][2] = King(0)
                self.board[0][0] = '.'
                if board.is_under_check_w(board):
                    self.board[0][3] = '.'
                    self.board[0][4] = King(0)
                    self.board[0][2] = '.'
                    self.board[0][0] = Rook(0)
                    return False
                self.color = 1
                self.board[0][4].castling()
                self.board[0][0].castling()
                board_copy = Board()
                board_copy.copy(board)
                self.moves.append(board_copy)
                self.step += 1
                return True
            else:
                return False
        if self.color == 1:
            if not (board.is_under_check_b(board)) and self.board[7][4] != '.' and self.board[7][4].name == 'K' and \
                    self.board[7][4].first_move and self.board[7][0] != '.' and self.board[7][0].name == 'R' and \
                    self.board[7][0].first_move and self.board[7][1] == '.' and self.board[7][2] == '.' and \
                    self.board[7][3] == '.':
                self.board[7][4] = '.'
                self.board[7][3] = King(1)
                if board.is_under_check_b(board):
                    self.board[7][3] = '.'
                    self.board[7][4] = King(1)
                    self.board[7][2] = '.'
                    self.board[7][0] = Rook(1)
                    return False
                self.board[7][3] = Rook(1)
                self.board[7][2] = King(1)
                self.board[7][0] = '.'
                if board.is_under_check_b(board):
                    self.board[7][3] = '.'
                    self.board[7][4] = King(1)
                    self.board[7][2] = '.'
                    self.board[7][0] = Rook(1)
                    return False
                self.color = 0
                self.board[7][4].castling()
                self.board[7][0].castling()
                board_copy = Board()
                board_copy.copy(board)
                self.moves.append(board_copy)
                self.step += 1
                return True
            else:
                return False
    def is_under_check_w(self, board):
        # under - под, check - шах, white - сокращение от white (белый),
        # Проверяет, находится ли белый король под шахом
        king_position = []
        # Список,в котором будут лежать нынешние координаты белого короля
        for i in range(8):
            for j in range(8):
                # Проходимся по всей доске и ищем белого короля
                if board.board[i][j] != '.':
                    if board.board[i][j].name == 'K' and board.board[i][j].color == 0:
                        king_position = [i, j]
                        # В king_position сохраняем координаты белого короля
        for i in range(8):
            if board.board[i][king_position[1]] != '.':
                # Проверка, есть ли фигуры по вертикали от короля
                if board.board[i][king_position[1]].name in ['R', 'Q'] and board.board[i][king_position[1]].color == 1:
                    # Если такая фигура есть, не черные ли это королева или ладья (башенка)
                    if all(board.board[j][king_position[1]] == '.' for j in
                           range(min(i, king_position[0]) + 1, max(i, king_position[0]))):
                        # Проверят, все ли пустые клетки между белым королем и черной королевой/ладьей
                        return True
        for j in range(8):
            if board.board[king_position[0]][j] != '.':
                # Проверка, есть ли фигуры по горизонтали от короля. Аналогична проверке по вертикали
                if board.board[king_position[0]][j].name in ['R', 'Q'] and board.board[king_position[0]][j].color == 1:
                    if all(board.board[king_position[0]][k] == '.' for k in
                           range(min(j, king_position[1]) + 1, max(j, king_position[1]))):
                        return True
        # 4 похожих цикла - проверка наличия шаха от черного слона или королевы (по 4 разным диагоналям)
        # Проверка по левой нижней диагонали
        for i, j in zip(range(king_position[0] - 1, -1, -1), range(king_position[1] - 1, -1, -1)):
            # zip() для создания пар координат. В i будет изменение по горизонательной оси с шагом -1. j будет изменение по вертикальной оси с шагом -1
            if board.board[i][j] != '.':
                if board.board[i][j].name in ['B', 'Q'] and board.board[i][j].color == 1:
                    # Проверяем, есть ли по диагонали от короля слон/королева
                    if all(board.board[i + x][j + x] == '.' for x in range(1, king_position[0] - i)):
                        # Проверяем, если фигуры между королем и королевой/слоном
                        return True
        # Проверка по нижней правой диагонали. Аналогичен верхнему перебору
        for i, j in zip(range(king_position[0] - 1, -1, -1), range(king_position[1] + 1, 8)):
            if board.board[i][j] != '.':
                if board.board[i][j].name in ['B', 'Q'] and board.board[i][j].color == 1:
                    if all(board.board[i + x][j - x] == '.' for x in range(1, king_position[0] - i)):
                        return True
        # Проверка по верхней левой диагонали. Аналогичен верхнему перебору
        for i, j in zip(range(king_position[0] + 1, 8), range(king_position[1] - 1, -1, -1)):
            if board.board[i][j] != '.':
                if board.board[i][j].name in ['B', 'Q'] and board.board[i][j].color == 1:
                    if all(board.board[i - x][j + x] == '.' for x in range(1, i - king_position[0])):
                        return True
        # Проверка по верхней правой диагонали. Аналогичен верхнему перебору
        for i, j in zip(range(king_position[0] + 1, 8), range(king_position[1] + 1, 8)):
            if board.board[i][j] != '.':
                if board.board[i][j].name in ['B', 'Q'] and board.board[i][j].color == 1:
                    if all(board.board[i - x][j - x] == '.' for x in range(1, i - king_position[0])):
                        return True
        pawn_moves = [(-1, 1), (-1, -1)]
        # pawn_moves - варианты расположения пешок, в которых она может съесть короля
        # Проверяем, находится ли король под ударом пешки:
        for move in pawn_moves:
            # Перебираем и проверяем, есть в клетках pawn_moves пешки
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                # Проверяем, если на коордианатах x, y пешка
                if board.board[x][y].name == 'P' and board.board[x][y].color == 1:
                    return True
        knight_moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
        # knight_moves - варианты расположения коня, в которых он может съесть короля
        # Проверяем, находится ли король под ударом коня:
        for move in knight_moves:
            # Перебираем и проверяем, есть в клетках knight_moves конь
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                # Проверяем, если на коордианатах x, y конь
                if board.board[x][y].name == 'N' and board.board[x][y].color == 1:
                    return True
        king_moves = [(0, 1), (1, 0), (1, 1), (-1, 0), (1, -1), (-1, -1), (0, -1), (-1, 1)]
        # king_moves - варианты расположения черного короля, в которых он может съесть белого короля
        # Проверяем, находится ли король под ударом короля:
        for move in king_moves:
            # Перебираем и проверяем, есть в клетках king_moves короли
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'K' and board.board[x][y].color == 1:
                    # Проверяем, если на коордианатах x, y король
                    return True
        samurai_moves = [(0, 2), (2, 0), (2, 2), (-2, 0), (2, -2), (-2, -2), (0, -2), (-2, 2)]
        # samurai_moves - варианты расположения черного самурая, в которых он может съесть белого короля
        # Проверяем, находится ли король под ударом самурая:
        for move in samurai_moves:
            # Перебираем и проверяем, есть в клетках king_moves самураи
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'S' and board.board[x][y].color == 1:
                    # Проверяем, если на коордианатах x, y самурай
                    return True
        wizard_moves = [(0, 1), (1, 0), (1, 1), (-1, 0), (1, -1), (-1, -1), (0, -1), (-1, 1)]
        # wizard_moves - варианты расположения черного волшебника, в которых он может съесть белого короля
        # Проверяем, находится ли король под ударом волшебника:
        for move in wizard_moves:
            # Перебираем и проверяем, есть в клетках king_moves волшебники
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'W' and board.board[x][y].color == 1:
                    # Проверяем, если на коордианатах x, y волшебник
                    return True
        if board.board[king_position[1]][king_position[0]] != '.':
            if board.board[king_position[1]][king_position[0]].name == 'W' and board.board[king_position[1]][king_position[0]].color == 1:
                # Проверяем, если на коордианатах king_position[1], king_position[0] волшебник
                return True

        dragon_moves = [(0, 2), (2, 0), (1, 1), (-2, 0), (1, -1), (-1, -1), (0, -2), (-1, 1)]
        # dragon_moves - варианты расположения черного дракона, в которых он может съесть короля
        # Проверяем, находится ли король под ударом дракона:
        for move in dragon_moves:
            # Перебираем и проверяем, есть в клетках king_moves драконы
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'D' and board.board[x][y].color == 1:
                    # Проверяем, если на коордианатах x, y дракон
                    return True
        return False
    def is_under_check_b(self, board):
        # Проверяет, находится ли черный король под шахом. Аналогичен is_under_check_w
        king_position = []
        for i in range(8):
            for j in range(8):
                if board.board[i][j] != '.':
                    if board.board[i][j].name == 'K' and board.board[i][j].color == 1:
                        king_position = [i, j]
        for i in range(8):
            if board.board[i][king_position[1]] != '.':
                if board.board[i][king_position[1]].name in ['R', 'Q'] and board.board[i][king_position[1]].color == 0:
                    if all(board.board[j][king_position[1]] == '.' for j in
                           range(min(i, king_position[0]) + 1, max(i, king_position[0]))):
                        return True
        for j in range(8):
            if board.board[king_position[0]][j] != '.':
                if board.board[king_position[0]][j].name in ['R', 'Q'] and board.board[king_position[0]][j].color == 0:
                    if all(board.board[king_position[0]][k] == '.' for k in
                           range(min(j, king_position[1]) + 1, max(j, king_position[1]))):
                        return True
        for i, j in zip(range(king_position[0] - 1, -1, -1), range(king_position[1] - 1, -1, -1)):
            if board.board[i][j] != '.':
                if board.board[i][j].name in ['B', 'Q'] and board.board[i][j].color == 0:
                    if all(board.board[i + x][j + x] == '.' for x in range(1, king_position[0] - i)):
                        return True
        for i, j in zip(range(king_position[0] - 1, -1, -1), range(king_position[1] + 1, 8)):
            if board.board[i][j] != '.':
                if board.board[i][j].name in ['B', 'Q'] and board.board[i][j].color == 0:
                    if all(board.board[i + x][j - x] == '.' for x in range(1, king_position[0] - i)):
                        return True
        for i, j in zip(range(king_position[0] + 1, 8), range(king_position[1] - 1, -1, -1)):
            if board.board[i][j] != '.':
                if board.board[i][j].name in ['B', 'Q'] and board.board[i][j].color == 0:
                    if all(board.board[i - x][j + x] == '.' for x in range(1, i - king_position[0])):
                        return True
        for i, j in zip(range(king_position[0] + 1, 8), range(king_position[1] + 1, 8)):
            if board.board[i][j] != '.':
                if board.board[i][j].name in ['B', 'Q'] and board.board[i][j].color == 0:
                    if all(board.board[i - x][j - x] == '.' for x in range(1, i - king_position[0])):
                        return True
        if king_position[0] > 0:
            if king_position[1] > 0 and board.board[king_position[0] - 1][king_position[1] - 1] != '.':
                if board.board[king_position[0] - 1][king_position[1] - 1].name == 'P' and \
                        board.board[king_position[0] - 1][king_position[1] - 1].color == 0:
                    return True
            if king_position[1] < 7 and board.board[king_position[0] - 1][king_position[1] + 1] != '.':
                if board.board[king_position[0] - 1][king_position[1] + 1].name == 'P' and \
                        board.board[king_position[0] - 1][king_position[1] + 1].color == 0:
                    return True
        pawn_moves = [(1, 1), (1, -1)]
        for move in pawn_moves:
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'P' and board.board[x][y].color == 0:
                    return True
        knight_moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
        for move in knight_moves:
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'N' and board.board[x][y].color == 0:
                    return True
        king_moves = [(0, 1), (1, 0), (1, 1), (-1, 0), (1, -1), (-1, -1), (0, -1), (-1, 1)]
        for move in king_moves:
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'K' and board.board[x][y].color == 0:
                    return True
        samurai_moves = [(0, 2), (2, 0), (2, 2), (-2, 0), (2, -2), (-2, -2), (0, -2), (-2, 2)]
        # samurai_moves - варианты расположения черного волшебника, в которых он может съесть белого короля
        # Проверяем, находится ли король под ударом самурая:
        for move in samurai_moves:
            # Перебираем и проверяем, есть в клетках king_moves самураи
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'S' and board.board[x][y].color == 1:
                    # Проверяем, если на коордианатах x, y волшебник
                    return True
        wizard_moves = [(0, 1), (1, 0), (1, 1), (-1, 0), (1, -1), (-1, -1), (0, -1), (-1, 1)]
        # wizard_moves - варианты расположения черного волшебника, в которых он может съесть белого короля
        # Проверяем, находится ли король под ударом волшебника:
        for move in wizard_moves:
            # Перебираем и проверяем, есть в клетках king_moves волшебники
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'W' and board.board[x][y].color == 1:
                    # Проверяем, если на коордианатах x, y волшебник
                    return True
        if board.board[king_position[1]][king_position[0]] != '.':
            if board.board[king_position[1]][king_position[0]].name == 'W' and board.board[king_position[1]][king_position[0]].color == 1:
                # Проверяем, если на коордианатах king_position[1], king_position[0] волшебник
                return True

        dragon_moves = [(0, 2), (2, 0), (1, 1), (-2, 0), (1, -1), (-1, -1), (0, -2), (-1, 1)]
        # dragon_moves - варианты расположения черного дракона, в которых он может съесть короля
        # Проверяем, находится ли король под ударом дракона:
        for move in dragon_moves:
            # Перебираем и проверяем, есть в клетках king_moves драконы
            x = king_position[0] + move[0]
            y = king_position[1] + move[1]
            if 0 <= x < 8 and 0 <= y < 8 and board.board[x][y] != '.':
                if board.board[x][y].name == 'D' and board.board[x][y].color == 1:
                    # Проверяем, если на коордианатах x, y дракон
                    return True
        return False
    def copy(self, board):
        # Создает гипотетическую доску для проверки возможности мата (тут проигрываются различные ходы, чтобы проверить, возможен ли хоть какой-то ход)
        self.board = [['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.'],
                      ['.', '.', '.', '.', '.', '.', '.', '.']]
        for i in range(8):
            for j in range(8):
                if board.board[i][j] != '.':
                    self.board[i][j] = board.board[i][j]
                    # Переносим на поле фигуры с нынешнего состояния доски
        self.color = board.color
        # Запоминаем, чей ход сейчас
    def check_moves(self, board):
        # check_moves проверяет, возможен ли хоть один ход в текущий момент игры
        for i in range(8):
            for j in range(8):
                if self.board[i][j] != '.' and self.board[i][j].color == self.color:
                    # Если это фигура цвета текущего игрока
                    all_moves = board.get_all_moves(board, [i, j])
                    # находим все возможные шаги
                    for start, to in all_moves:
                        # Проходимся по всем возможным ходам фигуры на координате (i, j)
                        board_moves = Board()
                        board_moves.copy(board)
                        # Создаем гипотетическую доску
                        board_moves.board[to[0]][to[1]] = board_moves.board[start[0]][start[1]]
                        board_moves.board[start[0]][start[1]] = '.'
                        # Передвигаем фигуру на гипотетической доске
                        if board_moves.color == 0 and not (board.is_under_check_w(board_moves)):
                            # Проверяем шах для текущего белого игрока
                            return True
                        if board_moves.color == 1 and not (board.is_under_check_b(board_moves)):
                            # Проверяем шах для текущего черного игрока
                            return True
        # Если не существует ни одного возможного хода
        return False
    def get_all_moves(self, board, start):
        # get_all_moves возвращает список всех возможных координат ходов выбранной фигуры в all_moves
        all_moves = []
        for i in range(8):
            for j in range(8):
                flag_first_move = False
                # Проверка на первый ход
                if self.board[start[0]][start[1]].name in ['P', 'R', 'K'] and self.board[start[0]][
                    start[1]].first_move == True:
                    flag_first_move = True
                if board.board[start[0]][start[1]].is_valid_move(board, start, [i, j]):
                    # Если ход в клетку с координатами i, j возможен, добалвяем его в all_moves
                    if self.board[start[0]][start[1]].name in ['P', 'R', 'K'] and flag_first_move:
                        # Если это пешка, король или ладья(башенка), то возвращаем им первый ход
                        self.board[start[0]][start[1]].first_move = True
                    all_moves.append([start, [i, j]])
        return all_moves
    def extra_eating(self, board, start):
        # extra_eating проверка на то, возможен ли двойной ход (съдение 2 фигур за раз)
        # start - координаты фигуры, которую мы проверяем на возможность двойного хода
        for i in range(8):
            for j in range(8):
                valid = board.board[start[0]][start[1]].is_valid_move(board, start, [i, j])
                # valid - список, в котором valid[0] - возможность сходить, valid[1] - возможность съесть
                if valid[0] and valid[1]:
                    return True
        return False
    def move_piece_checkers(self, board, start, to):
        if self.board[start[0]][start[1]] != '.':
            # Есть ли в начальных координатах фигура
            if self.color == self.board[start[0]][start[1]].color:
                # Фигуру цвета текущего игрока двигают ли
                if not(self.additional_move):
                    # Проверка на то, не двойной ли ход сейчас
                    valid = self.board[start[0]][start[1]].is_valid_move(board, start, to)
                    # В valid список, в которой valid[0] хранит возможность хода, valid[1] было ли съедение 
                    if valid[0]:
                        # Если можно сходить
                        if valid[1]:
                        # Если съешки шашку в прошлом ходу
                            a = start[0]
                            b = start[1]
                            while a != to[0]:
                                # Проходимся по диагонали по координатам, которые прошла фишки и удаляем оттуда все съеденные шашки
                                a -= (abs(start[0] - to[0]) // (start[0] - to[0]))
                                b -= (abs(start[1] - to[1]) // (start[1] - to[1]))
                                board.board[a][b] = '.'
                            self.board[to[0]][to[1]] = self.board[start[0]][start[1]]
                            # Переходим шашку на конечную координату
                            self.board[start[0]][start[1]] = '.'
                            # На старой координате удаляем шашку
                            self.previous_piece = to
                            # Запоминаем, какой фигурой мы ходили до этого (чтобы если что именно ей сделать дополнителбный ход)
                            for i in range(8):
                                # Проходимся по первому и последнему ряду поля
                                if board.board[0][i] != '.' and board.board[0][i].name == 'C' and board.board[0][
                                    i].color == 1:
                                    # Ищем черные шашки на нижнем ряду 
                                    board.board[0][i] = Checker_Queen(1)
                                    # Checker_Queen делает пешку королевой 
                                    self.additional_move = True
                                    return True
                                if board.board[7][i] != '.' and board.board[7][i].name == 'C' and board.board[7][
                                    i].color == 0:
                                    # Ищем белые шашки на верхнем ряду
                                    self.additional_move = True
                                    board.board[7][i] = Checker_Queen(0)
                                    # Checker_Queen делает пешку королевой 
                                    return True
                            if board.extra_eating(board, to):
                                # Проверка на возможность дополнительного хода (если можно еще кого-то съесть)
                                self.additional_move = True
                                self.eaten = True
                                return True
                        else:
                            # Если нельзя съесть фигуру 
                            self.board[to[0]][to[1]] = self.board[start[0]][start[1]]
                            self.board[start[0]][start[1]] = '.'
                            self.previous_piece = to
                            for i in range(8):
                                # Аналогичная вверхней проверка на появление королев 
                                if board.board[0][i] != '.' and board.board[0][i].name == 'C' and board.board[0][i].color == 1:
                                    board.board[0][i] = Checker_Queen(1)
                                    self.additional_move = True
                                    return True
                                if board.board[7][i] != '.' and board.board[7][i].name == 'C' and board.board[7][i].color == 0:
                                    self.additional_move = True
                                    board.board[7][i] = Checker_Queen(0)
                                    return True
                        if self.color == 1:
                            # Меняем текущего игрока
                            self.color = 0
                        else:
                            self.color = 1
                        return True
                else:
                    # Если это дополнительный ход
                    if start == self.previous_piece:
                        # В previous_piece координаты фигуры, которую мы двигали до этого 
                        # Может быть 2 варианта, почему сейчас дополнительный ход (если можно кого-то съесть или если шашка стала королевой)
                        if self.eaten:
                            # Если можно кого-то съесть. Аналогично вверхнему кроме того, что нет возможности не есть шашку
                            valid = self.board[start[0]][start[1]].is_valid_move(board, start, to)
                            if valid[0] and valid[1]:
                                a = start[0]
                                b = start[1]
                                while a != to[0]:
                                    a -= (abs(start[0] - to[0]) // (start[0] - to[0]))
                                    b -= (abs(start[1] - to[1]) // (start[1] - to[1]))
                                    board.board[a][b] = '.'
                                self.board[to[0]][to[1]] = self.board[start[0]][start[1]]
                                self.board[start[0]][start[1]] = '.'
                                self.previous_piece = to
                                for i in range(8):
                                    if board.board[0][i] != '.' and board.board[0][i].name == 'C' and board.board[0][
                                        i].color == 1:
                                        board.board[0][i] = Checker_Queen(1)
                                        self.additional_move = True
                                        return True
                                    if board.board[7][i] != '.' and board.board[7][i].name == 'C' and board.board[7][
                                        i].color == 0:
                                        self.additional_move = True
                                        board.board[7][i] = Checker_Queen(0)
                                        return True
                                if board.extra_eating(board, to):
                                    self.additional_move = True
                                    self.eaten = True
                                    return True
                                if self.color == 1:
                                    self.color = 0
                                else:
                                    self.color = 1
                                self.additional_move = False
                                self.eaten = False
                                return True

                            if valid[0]:
                                # Если пользователь не ест шашку
                                print('Вам нужно съесть фигуру')
                                return False
                            return False 
                        else:
                            # Если шашкой стала королевой. Аналогичная вверхнему ходу шашки
                            valid = self.board[start[0]][start[1]].is_valid_move(board, start, to)
                            if valid[0]:
                                if valid[1]:
                                    # Если можно съесть шашку
                                    a = start[0]
                                    b = start[1]
                                    while a != to[0]:
                                        a -= (abs(start[0] - to[0]) // (start[0] - to[0]))
                                        b -= (abs(start[1] - to[1]) // (start[1] - to[1]))
                                        board.board[a][b] = '.'
                                    self.board[to[0]][to[1]] = self.board[start[0]][start[1]]
                                    self.board[start[0]][start[1]] = '.'
                                    self.previous_piece = to
                                    for i in range(8):
                                        if board.board[0][i] != '.' and board.board[0][i].name == 'C' and \
                                                board.board[0][
                                                    i].color == 1:
                                            board.board[0][i] = Checker_Queen(1)
                                            self.additional_move = True
                                            return True
                                        if board.board[7][i] != '.' and board.board[7][i].name == 'C' and \
                                                board.board[7][
                                                    i].color == 0:
                                            self.additional_move = True
                                            board.board[7][i] = Checker_Queen(0)
                                            return True
                                    if board.extra_eating(board, to):
                                        self.additional_move = True
                                        self.eaten = True
                                        return True
                                else:
                                    # Если нельзя съесть шашку
                                    self.board[to[0]][to[1]] = self.board[start[0]][start[1]]
                                    self.board[start[0]][start[1]] = '.'
                                    self.previous_piece = to
                                    for i in range(8):
                                        if board.board[0][i] != '.' and board.board[0][i].name == 'C' and \
                                                board.board[0][i].color == 1:
                                            board.board[0][i] = Checker_Queen(1)
                                            self.additional_move = True
                                            return True
                                        if board.board[7][i] != '.' and board.board[7][i].name == 'C' and \
                                                board.board[7][i].color == 0:
                                            self.additional_move = True
                                            board.board[7][i] = Checker_Queen(0)
                                            return True
                                if self.color == 1:
                                    self.color = 0
                                else:
                                    self.color = 1
                                self.additional_move = False
                                self.eaten = False
                                return True
                    else:
                        # Если в дополнительный ход двигаем не ту фигуру, которую двигали в прошлый
                        print("Вам нужно сходить той же фигурой, что и в предыдущий ход")
                        return False
        return False
    def count_pieces(self, board):
        # count_pieces считает количество белых и черных фигур на доске
        w = 0
        b = 0
        for i in range(8):
           for j in range(8):
               if board.board[i][j] != '.':
                   if board.board[i][j].color == 0:
                       w += 1
                   else:
                       b += 1
        return [w, b]
def translate(s):
    # translate - переводит коордианты "в шахматах" (например, e1) в целочисленные координаты (e1 -> (0,4))
    # s - здесь координата в "шахматном" виде (например, e1)
    try:
        col = s[0]
        # в col будет буква (например, e)
        row = int(s[1])
        # в col будет числа (например, 1)
        if row < 1 or row > 8:
            print(s[1] + " не между 1 - 8")
            return None
        if col < 'a' or col > 'h':
            # Буквы сравниваются по номеру в таблице ascii
            print(s[0] + " не между a - h")
            return None
        dict = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}
        return (row - 1, dict[col])
    except:
        # Если s неправильного "шахматного" формата
        print(s + " не в формате '[letter][number]'")
        return None
def main():
    # main общается с пользователем
    step = 1
    # step - счетчик ходов
    print('Во что вы хотите сыграть шахматы или шашки?')
    if input() == 'шахматы'.lower():
        # Если играем в шахматы
        board = Board(0)
        # Создаем пустую доску. 0 - шахматы, 1 - шашки
        while True:
            # Цикл завершится, когда завершится игра
            # Проверка на мат или пат для белого и черного игрока
            if board.color == 0:
                if board.is_under_check_w(board) and not (board.check_moves(board)):
                    print('Мат, выиграли черные')
                    break
                elif board.is_under_check_w(board) == False and not (board.check_moves(board)):
                    print('Пат, ничья')
                    break
            else:
                if board.check_moves(board) == False and board.is_under_check_b(board):
                    print('Мат, выиграли белые')
                    break
                elif board.check_moves(board) == False and not (board.is_under_check_b(board)):
                    print('Пат, ничья')
                    break
            board.print_board()
            # Выводим доску
            print('Ход №' + str(step))
            if board.color == 0:
                print('Ход белых:')
            else:
                print('Ход чёрных:')
            command = input().split()
            # command - ввод от пользователя хода
            if len(command) == 0:
                print('Неправильный ввод, повторите попытку')
                continue
            if command[0] == 'exit':
                break
                # Возможность выхода из  игр
            if command[0] == '0-0':
                # '0-0' - короткая рокировка
                if board.castling_s(board):
                    print('Ход успешен')
                    step += 1
                continue
            if command[0] == '0-0-0':
                # '0-0-0' - длинная рокировка
                if board.castling_l(board):
                    print('Ход успешен')
                    step += 1
                else:
                    print('Вы не можете пойти сюда. Повторите попытку')
                continue
            if command[0] == 'откат':
                if len(command) > 1:
                    board.rollback(board)
                    # Откат по умолчанию на 1 ход назад
                else:
                    board.rollback(board, int(command[1]))
                    # Иначе на количество ходов, указанныз пользователем
                continue
            if len(command) != 2:
                print('Неправильный ввод, повторите попытку')
                continue
            a = command[0].lower()
            b = command[1].lower()
            start = translate(a)
            to = translate(b)
            if not (start) or not (to):
                # для некорректно введенной координаты
                continue
            if board.move_piece(board, start, to):
                # move_piece - перемещает фигуру
                print('Ход успешен')
                step += 1
            else:
                print('Вы не можете пойти сюда. Повторите попытку')

            for i in range(8):
                # Проверяем, есть ли пешка на противоположном крае
                if board.board[0][i] != '.':
                    if board.board[0][i].name == 'P':
                        print('Выберите, во что хотите превратить пешку:')
                        print('Q: королева')
                        print('B: слон')
                        print('R: ладья')
                        print('N: конь')
                        print('S: самурай')
                        print('W: волшебник')
                        print('D: дракон')
                        piece = input()
                        board.change_piece(piece, 0, i)
                        # Меняем пешку на выбранную фигуру
                # Аналогично для другого края доски
                if board.board[7][i] != '.':
                    if board.board[7][i].name == 'P':
                        print('Выберите, во что хотите превратить пешку:')
                        print('Q: королева')
                        print('B: слон')
                        print('R: ладья')
                        print('N: конь')
                        print('S: самурай')
                        print('W: волшебник')
                        print('D: дракон')
                        piece = input()
                        board.change_piece(piece, 7, i)
    else:
        # Если играем в шашки
        board = Board(1)
        # Создаем поле шашек
        while True:
            # Пока идет игра
            count = board.count_pieces(board)
            # count - список, в котоом сначала записано количество белых шашек, потом черных
            if count[0] == 0:
                print('Победили черные')
                break
            if count[1] == 0:
                print('Победили белые')
                break
            board.print_board()
            # Выводим доску
            if board.color == 0:
                print('Ход белых:')
            else:
                print('Ход чёрных:')
            command = input().split()
            # command - ввод от пользователя хода
            if len(command) == 0:
                print('Неправильный ввод, повторите попытку')
                continue
            if command[0] == 'exit':
                break
                # Возможность выхода из игры
            if len(command) != 2:
                print('Неправильный ввод, повторите попытку')
                continue
            a = command[0].lower()
            b = command[1].lower()
            start = translate(a)
            # translate переводит координаты в формат шашек
            to = translate(b)
            if not (start) or not (to):
                # для некорректно введенной координаты
                continue
            if board.move_piece_checkers(board, start, to):
                # move_piece - перемещает фигуру
                print('Ход успешен')
            else:
                print('Вы не можете пойти сюда. Повторите попытку')


if __name__ == "__main__":
    # Запуск программы
    main()
